//102960124
//https://contest.yandex.ru/contest/25597/run-report/102960124/

package Yandex.Algo_course.Sprint7;

/*
ПРИНЦИП РАБОТЫ
Схож с поиском НОП, только выбираются минимальные числа. Переходом будет "Замена" - +1 действие по диагонали,
либо "Удаление" (которое является вставкой для второй строки) - +1 действие по ортогонали.
Базой будет приведение строки к строке нулевой длины - "удалить каждый символ", поэтому каёмочка dp будет заполнена {0, 1, 2, ..., length}

Легенда оценки: M - длина первой строки, N - длина второй строки.
 */

/*
ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ
Базой является случай, когда строки не совпадают по длине - (s1, ""), ответом будет число операций удаления, равное длине s1. Аналогично для ("", s2).
Если буквы на позиции совпали - это аналогично ситуации, что этих букв в строках нет, то есть расстояние Левинштейна (LEV) для совпавших букв равно расстоянию без этих букв вообще:
LEV( [any]a , [som]a ) = LEV( [any], [som] ), как будто буквы "a" нет в этих строках. Переходом будет значение из клетки по диагонали.

Если же буквы не совпадают, то мы можем сделать 3 действия - заменить букву, удалить её из первой строки или удалить из второй. Все три действия увеличат LEV на +1.
Различаться будут только направления исходных данных: в случае, если происходит замена буквы, исходное-переходное будет по диагонали.
Если удаление - то, в зависимости от того, из какой строки удаляется буква, переход будет либо по вертикали, либо по горизонтали.
Так как нам нужно минимальное расстояние, а стоимость вставки-удаления-замены одинаковая, берем минимум из смежных "исходных-переходных + 1".

Таким образом, заполняем всю матрицу dp, и ответ будет в правом нижнем углу матрицы.
 */


/*
ВРЕМЕННАЯ СЛОЖНОСТЬ
Необходимо N + M + N*M операций - заполнение базы и вложенный цикл по всем элементам двумерного массива.
Итоговая сложность: O(N*M)
 */

/*
ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ
Помимо хранения исходных строк O(N + M), используется динамический двумерный массив с каёмочкой, размером (N+1)*(M+1), дополнительных структур не предполагается.
Итоговая сложность: O(N*M).
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Sprint7FinalA {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        char[] firstChars = br.readLine().toCharArray();
        char[] secondChars = br.readLine().toCharArray();

        int[][] dp = new int[firstChars.length + 1][secondChars.length + 1];

        //Заполним базу - каёмочку
        for (int i = 0; i < firstChars.length + 1; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i < secondChars.length + 1; i++) {
            dp[0][i] = i;
        }

        //Динамические переходы
        for (int f = 1; f < firstChars.length + 1; f++) {
            for (int s = 1; s < secondChars.length + 1; s++) {
                if (firstChars[f - 1] == secondChars[s - 1]) {
                    dp[f][s] = dp[f - 1][s - 1];
                } else {
                    dp[f][s] = Math.min(Math.min(dp[f][s - 1] + 1, dp[f - 1][s] + 1), dp[f - 1][s - 1] + 1);
                }
            }
        }

        //Ответ будет в правом нижнем углу
        System.out.println(dp[firstChars.length][secondChars.length]);
    }
}
